<!DOCTYPE html>
{% load static %}
{% load my_filter %}
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chart</title>
    <link rel="stylesheet" href="{% static 'css/for_chart.css' %}">
    <style>
    </style>
</head>
<body>

<!-- Create a div where the graph will take place -->
<div id="dataVis" class="chart_container">
    <div class="chart">
        <svg id="word_cloud"></svg>
    </div>
    <div class="chart">
        <svg id="donut"></svg>
    </div>
    <div class="chart">
        <svg id="chart_d_y"></svg>
    </div>
    <div class="chart">
        <svg id="treemap"></svg>
    </div>
</div>

<script>
    const containerWidth = d3.select('.chart_container').node().getBoundingClientRect().width;
    const containerHeight = d3.select('.chart_container').node().getBoundingClientRect().height;
    const chartWidth = containerWidth; // 每个图表宽度占容器的25%
    const chartHeight = containerHeight / 4;
    const marginTop = 30;
    const marginRight = 30;
    const marginBottom = 20;
    const marginLeft = 50;

    // 通用的缩放功能
    function zoom_chart(svg, x, chartWidth, chartHeight) {
        const extent = [[marginLeft, marginTop], [chartWidth - marginRight, chartHeight - marginTop]];

        svg.call(d3.zoom()
            .scaleExtent([1, 8])
            .translateExtent(extent)
            .extent(extent)
            .on("zoom", zoomed));

        function zoomed(event) {
            const scale = event.transform.k;
            x.range([marginLeft, chartWidth - marginRight].map(d => event.transform.applyX(d)));
            svg.selectAll(".bars rect")
                .attr("x", d => x(d.author))
                .attr("width", x.bandwidth());
            const xAxisGroup = svg.selectAll(".x-axis");
            xAxisGroup.call(d3.axisBottom(x).tickFormat(scale < 3 ? '...' : d => d.split(' ')[1]));
            xAxisGroup.selectAll("text")
                .style("text-anchor", "middle");
        }
    }

    // 单独的图表1绘制函数
    function createChart1(svg, data) {
        const colorScale_chart = d3.scaleLinear()
            .domain([2020, 2024])
            .range(["#e6b1be", "#d14163"]);


        const x = d3.scaleBand()
            .domain(data.map(d => d.year))
            .range([marginLeft, chartWidth - marginRight])
            .padding(0.3);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.papers)]).nice()
            .range([chartHeight - marginBottom, marginTop]);

        svg.attr("viewBox", [0, 0, chartWidth, chartHeight])
            .attr("style", "width: 100%; height: 100%;");

        svg.append("g")
            .attr("class", "bars")
            .selectAll("rect")
            .data(data)
            .join("rect")
            .attr("x", d => x(d.year))
            .attr("y", d => y(d.papers))
            .attr("height", d => y(0) - y(d.papers))
            .attr("width", x.bandwidth())
            .attr("fill", d => colorScale_chart(d.year))
            .on('click', function (e, d) {
                highlightPapersByYear(d.year)
            })
            .on("mouseover", function (event, d) {
                const currentColor = d3.select(this).attr("fill");
                d3.select(this)
                    .attr("fill", d3.rgb(currentColor).darker(1.2));
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(
                    () => {
                        return d.papers
                    })
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function () {
                const originalColor = d3.select(this).attr("fill");
                d3.select(this).attr("fill", d3.rgb(originalColor).brighter(1.2));
                tooltip.transition().duration(500).style("opacity", 0);
            });

        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${chartHeight - marginBottom})`)
            .call(d3.axisBottom(x).tickSizeOuter(0));

        svg.append("g")
            .attr("class", "y-axis")
            .attr("transform", `translate(${marginLeft},0)`)
            .call(d3.axisLeft(y).tickFormat(d3.format(".2s")))
            .call(g => g.select(".domain").remove());

        if (data.length > 10) {
            svg.selectAll(".x-axis text")
                .text('...');
        }
    }

    // 单独的图表2绘制函数
    function createChart2(svg, data) {

        const x = d3.scaleBand()
            .domain(data.map(d => d.department))
            .range([marginLeft, chartWidth - marginRight])
            .padding(0.5);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.papers)]).nice()
            .range([chartHeight - marginBottom, marginTop]);

        svg.attr("viewBox", [0, 0, chartWidth, chartHeight])
            .attr("style", "width: 100%; height: 100%;");

        svg.append("g")
            .attr("class", "bars")
            .selectAll("rect")
            .data(data)
            .join("rect")
            .attr("fill", function (d) {
                if (d.department === 'AI') {
                    return '#247485'
                } else if (d.department === 'CMA') {
                    return '#64a4af'
                } else if (d.department === 'DSA') {
                    return '#22465b'
                }
            })
            .attr("x", d => x(d.department))
            .attr("y", d => y(d.papers))
            .attr("height", d => y(0) - y(d.papers))
            .attr("width", x.bandwidth())
            .on('click', function (e, d) {
                const sNode = {'name': d.department}
                highlightNeighborhood_2(sNode)
            })
            .on("mouseover", function (event, d) {
                // 获取当前颜色并在鼠标悬浮时加深
                const currentColor = d3.select(this).attr("fill");
                d3.select(this)
                    .attr("fill", d3.rgb(currentColor).darker(1.2));
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(`${d.department}<br>${d.papers}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function () {
                // 恢复原来的颜色
                const originalColor = d3.select(this).attr("fill");
                d3.select(this).attr("fill", d3.rgb(originalColor).brighter(1.2));
                tooltip.transition().duration(500).style("opacity", 0);
            });

        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${chartHeight - marginBottom})`)
            .call(d3.axisBottom(x).tickSizeOuter(0));

        svg.append("g")
            .attr("class", "y-axis")
            .attr("transform", `translate(${marginLeft},0)`)
            .call(d3.axisLeft(y).tickFormat(d3.format(".2s")))
            .call(g => g.select(".domain").remove());

    }

    // 单独的图表3绘制函数
    function createChart(svg, data) {
        const keys = ["AI", "CMA", "DSA"];
        console.log(data)
        const x = d3.scaleBand()
            .domain(data.map(d => d.year))
            .range([marginLeft, chartWidth - marginRight])
            .padding(0.3);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.AI + d.CMA + d.DSA)]).nice()
            .range([chartHeight - marginBottom, marginTop]);

        const color = d3.scaleOrdinal()
            .domain(keys)
            .range(["#22788a", "#68aab6", "#22475d"]);

        const stack = d3.stack()
            .keys(keys)
            .order(d3.stackOrderNone)
            .offset(d3.stackOffsetNone);

        const series = stack(data);

        svg.attr("viewBox", [0, 0, chartWidth, chartHeight])
            .attr("style", "width: 100%; height: 100%;");

        svg.append("g")
            .attr("class", "bars")
            .selectAll("g")
            .data(series)
            .join("g")
            .attr("fill", d => {
                return color(d.key)
            })
            .selectAll("rect")
            .data(d => d)
            .join("rect")
            .attr("x", d => x(d.data.year))
            .attr("y", d => y(d[1]))
            .attr("height", d => y(d[0]) - y(d[1]))
            .attr("width", x.bandwidth())
            .on('click', function (e, d) {

                highlightByDepartmentAndYear(d3.select(this.parentNode).datum().key, String(d.data.year))
            })
            .on("mouseover", function (event, d) {
                const key = d3.select(this.parentNode).datum().key;
                const value = d[1] - d[0];
                d3.select(this)
                    .attr("fill", d3.rgb(color(key)).darker(1.2));
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(`${key}<br>${value}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function (event, d) {
                const key = d3.select(this.parentNode).datum().key;
                d3.select(this)
                    .attr("fill", color(key));
                tooltip.transition().duration(500).style("opacity", 0);
            });

        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${chartHeight - marginBottom})`)
            .attr("font-size", "20px")
            .call(d3.axisBottom(x).tickSizeOuter(0));

        svg.append("g")
            .attr("class", "y-axis")
            .attr("transform", `translate(${marginLeft},0)`)
            .call(d3.axisLeft(y).tickFormat(d3.format(".2s")))
            .call(g => g.select(".domain").remove());
    }

    // 单独的图表4绘制函数
    function createChart4(svg, data) {
        const colorScale_auther_chart = d3.scaleLinear()
            .domain([18, 249])
            .range(["#e0f3e5", "#007f5f"]);

        const x = d3.scaleBand()
            .domain(data.map(d => d.author))
            .range([marginLeft, chartWidth - marginRight])
            .padding(0.3);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.papers)]).nice()
            .range([chartHeight - marginBottom, marginTop]);

        svg.attr("viewBox", [0, 0, chartWidth, chartHeight])
            .attr("style", "width: 100%; height: 100%;");

        svg.append("g")
            .attr("class", "bars")
            .selectAll("rect")
            .data(data)
            .join("rect")
            .attr("fill", d => colorScale_auther_chart(d.papers))
            .attr("x", d => x(d.author))
            .attr("y", d => y(d.papers))
            .attr("height", d => y(0) - y(d.papers))
            .attr("width", x.bandwidth())
            .on('click', function (e, d) {
                const sNode = {'name': d.author}
                highlightNeighborhood(sNode)
            })
            .on("mouseover", function (e, d) {
                // 获取当前颜色并在鼠标悬浮时加深
                const currentColor = d3.select(this).attr("fill");
                d3.select(this)
                    .attr("fill", d3.rgb(currentColor).darker(1.2));
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(
                    () => {
                        return d.author + '<br>' + d.papers
                    })
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function () {
                // 恢复原来的颜色
                const originalColor = d3.select(this).attr("fill");
                d3.select(this).attr("fill", d3.rgb(originalColor).brighter(1.2));
                tooltip.transition().duration(500).style("opacity", 0);
            });

        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${chartHeight - marginBottom})`)
            .call(d3.axisBottom(x).tickSizeOuter(0).tickFormat(d => data.length > 20 ? '...' : d.split(' ')[1]))
            .selectAll("text")
            .style("text-anchor", "middle")
            .attr("font-size", "10px");

        svg.append("g")
            .attr("class", "y-axis")
            .attr("transform", `translate(${marginLeft},0)`)
            .call(d3.axisLeft(y).tickFormat(d3.format(".2s")))
            .call(g => g.select(".domain").remove());

        if (data.length > 10) {
            svg.selectAll(".x-axis text")
                .text('...');
        }

        if (data.length > 10) {
            zoom_chart(svg, x, chartWidth, chartHeight);
        }
    }


    // 绘制矩形和文本
    function drawTreemap(svg, data) {
        // 定义外部间距
        const margin = {top: 20, right: 20, bottom: 20, left: 20};
        const width = 800 - margin.left - margin.right;  // 减去左右间距
        const height = 600 - margin.top - margin.bottom; // 减去上下间距



        // 创建根节点
        const root = d3.hierarchy(data)
            .sum(d => d.value)  // 聚合每个节点的value
            .sort((a, b) => b.value - a.value);  // 根据value排序

        // 创建treemap布局
        const treemap = d3.treemap()
            .size([width, height])  // 使用更新后的大小
            .padding(2)  // 设置每个节点之间的间隔
            .paddingInner(4)  // 部门之间的间隔
            (root);

        const departmentColors = {
            "AI": "#247485",
            "CMA": "#64a4af",
            "DSA": "#22465b"
        };

        // 绑定数据，创建每个矩形元素
        const nodes = svg
            .attr("viewBox", [0, 0, width + margin.left + margin.right, height + margin.top + margin.bottom]) // 使用更新后的视口
            .attr("style", "width: 100%; height: 100%;")
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`); // 应用间距

        // 绑定数据，创建每个矩形元素
        const rects = nodes
            .selectAll("g")
            .data(root.leaves())
            .enter()
            .append("g")
            .attr("transform", d => `translate(${d.x0},${d.y0})`);

        // 绘制矩形
        rects.append("rect")
            .attr("class", "node")
            .attr("id", d => d.data.name)
            .attr("width", d => d.x1 - d.x0)
            .attr("height", d => d.y1 - d.y0)
            .attr("fill", d => {
                console.log(departmentColors[d.parent.data.name])
                return departmentColors[d.parent.data.name]
            })  // 根据department设置颜色
            .on("mouseover", function (event, d) {
                // 获取当前填充颜色
                const currentColor = d3.color(d3.select(this).attr("fill"));

                // 计算新颜色（深 1.2 倍）
                const darkerColor = d3.color(currentColor).darker(1.2);

                // 设置新颜色
                d3.select(this)
                    .attr("fill", darkerColor);

                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(d.data.name)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function (event, d) {
                // 恢复原始颜色
                d3.select(this)
                    .attr("fill", departmentColors[d.parent.data.name]);
                tooltip.transition().duration(500).style("opacity", 0);
            })
            .on('click', function (e, d) {
                const sNode = {'name': d.data.name}
                highlightNeighborhood(sNode)
            });

        // 添加文本标签
        rects.append("text")
            .attr("x", 5)  // 设置文本的X位置
            .attr("y", 20) // 设置文本的Y位置
            .attr('font-size', "20px")
            .text(d => `${d.data.value}`)
            .attr("fill", "white");  // 设置文本颜色为白色
    }


    const radius = Math.min(chartWidth, chartHeight) / 2 - 25;

    // 定义颜色比例尺
    const color_test = d3.scaleOrdinal(d3.schemeCategory10);

    // 定义弧生成器
    const arc = d3.arc()
        .innerRadius(radius - Math.min(chartWidth, chartHeight) / 3.2 + 10)  // Donut Chart 的内半径
        .outerRadius(radius);       // Donut Chart 的外半径

    // 定义饼图生成器
    const pie = d3.pie()
        .value(d => d.value)
        .sort(null);

    // 定义全局变量，用于存储弧形和标签元素
    let arcs, labels, lines;

    function createDonut(svg, data) {

        const g = svg
            .attr("viewBox", [0, 0, chartWidth, chartHeight])
            .attr("style", "width: 100%; height: 100%;")
            .append("g")
            .attr("transform", `translate(${chartWidth / 2},${chartHeight / 2})`);


        // 绑定数据，绘制弧形路径
        arcs = g.selectAll("path")
            .data(pie(data))
            .enter().append("path")
            .attr("fill", function (d) {
                if (d.data.department === 'Dept.1') {
                    return '#247485'
                } else if (d.data.department === 'Dept.2') {
                    return '#64a4af'
                } else if (d.data.department === 'Dept.3') {
                    return '#22465b'
                }
            })
            .attr("d", arc)
            .on("mouseover", function (event, d) {
                // 获取当前填充颜色
                const currentColor = d3.color(d3.select(this).attr("fill"));

                // 计算新颜色（深 1.2 倍）
                const darkerColor = d3.color(currentColor).darker(1.2);

                // 设置新颜色
                d3.select(this)
                    .attr("fill", darkerColor);

                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(d.data.department)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function (event, d) {
                // 恢复原始颜色
                d3.select(this)
                    .attr("fill", function (d) {
                        if (d.data.department === 'Dept.1') {
                            return '#247485'
                        } else if (d.data.department === 'Dept.2') {
                            return '#64a4af'
                        } else if (d.data.department === 'Dept.3') {
                            return '#22465b'
                        }
                    });
                tooltip.transition().duration(500).style("opacity", 0);
            })
            .on('click', function (e, d) {
                if (d.data.department === 'Dept.1') {
                    highlightNeighborhood_2({'name': 'AI'})
                } else if (d.data.department === 'Dept.2') {
                    highlightNeighborhood_2({'name': 'CMA'})
                } else {
                    highlightNeighborhood_2({'name': 'DSA'})
                }
            })
            .each(function (d) {
                this._current = d;
            }); // 保存当前弧



        updateLabelsAndLines(data, g)

    }

    function updateLabelsAndLines(data, g) {
        // 先清除之前的线条和标签
        g.selectAll(".label").remove();
        g.selectAll(".line").remove();

        const offset = 20;  // 偏移量，用于将线条稍微偏移出饼图
        const outerArc = d3.arc()
            .innerRadius(radius * 1.1)
            .outerRadius(radius * 1.1);  // 外部弧，用于确定线条的折点

        // 更新线条
        lines = g.selectAll(".line")
            .data(pie(data))
            .enter()
            .append("polyline")  // 使用polyline创建带折线的线条
            .attr("class", "line")
            .attr("points", d => {
                const pos = outerArc.centroid(d);  // 第一个折点：稍微偏移出饼图
                const midAngle = (d.startAngle + d.endAngle) / 2;
                pos[0] = radius * (midAngle < Math.PI ? 1 : -1);  // 判断线条是朝左还是朝右
                const centroid = arc.centroid(d);  // 起点：扇形的中心
                return [centroid, outerArc.centroid(d), pos];  // 三个点构成折线
            })
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            .attr("fill", "none");

        // 添加外部标签
        labels = g.selectAll(".label")
            .data(pie(data))
            .enter()
            .append("text")
            .attr("class", "label")
            .attr("x", d => {
                const pos = outerArc.centroid(d);
                const midAngle = (d.startAngle + d.endAngle) / 2;
                pos[0] = radius * (midAngle < Math.PI ? 1 : -1);  // 将标签放在左侧或右侧
                return pos[0] + (midAngle < Math.PI ? 10 : -10);  // 偏移以避免贴线条太近
            })
            .attr("y", d => outerArc.centroid(d)[1])
            .attr("text-anchor", d => {
                const midAngle = (d.startAngle + d.endAngle) / 2;
                return midAngle < Math.PI ? "start" : "end";  // 根据角度调整对齐方式
            })
            .each(function (d) {
                const label = `${d.data.department}: ${d.data.value}`;
                const [department, value] = label.split(': ');  // 分成两行

                d3.select(this).append("tspan")  // 第一行：部门名称
                    .attr("x", d => {
                        const pos = outerArc.centroid(d);
                        const midAngle = (d.startAngle + d.endAngle) / 2;
                        pos[0] = radius * (midAngle < Math.PI ? 1 : -1);
                        return pos[0] + (midAngle < Math.PI ? 10 : -10);
                    })
                    .attr("y", outerArc.centroid(d)[1])
                    .text(department);

                d3.select(this).append("tspan")  // 第二行：数值
                    .attr("x", d => {
                        const pos = outerArc.centroid(d);
                        const midAngle = (d.startAngle + d.endAngle) / 2;
                        pos[0] = radius * (midAngle < Math.PI ? 1 : -1);
                        return pos[0] + (midAngle < Math.PI ? 10 : -10);
                    })
                    .attr("dy", "1.2em")  // 将第二行向下移动
                    .text(value);
            });
    }

    function updateDonut() {
        // 生成新的随机数据
        const newData = [
            {department: "Dept. A", value: Math.floor(Math.random() * 100)},
            {department: "Dept. B", value: Math.floor(Math.random() * 100)},
            {department: "Dept. C", value: Math.floor(Math.random() * 100)}
        ];

        // 重新绑定数据
        const newArcs = pie(newData);

        // 更新弧形路径的动画
        arcs.data(newArcs)
            .transition()
            .duration(1000)
            .attrTween("d", function (d) {
                const interpolate = d3.interpolate(this._current, d);
                this._current = interpolate(0);
                return t => arc(interpolate(t));
            });

        // 更新文本标签的位置和内容
        labels.data(newArcs)
            .transition()
            .duration(1000)
            .attr("transform", d => {
                const [x, y] = arc.centroid(d);
                return `translate(${x},${y})`;
            })
            .text(d => `${d.data.department}: ${d.data.value}`);
    }


    let words = []
    let colorMap = {};

    function initWordCloud() {
        d3.layout.cloud().size([chartWidth, chartHeight])
            .words(words.map(function (d) {
                return {text: d.text, size: d.size};
            }))
            .padding(5)
            .rotate(0) // All words will be horizontal
            .font("Impact")
            .fontSize(function (d) {
                return d.size;
            })
            .on("end", draw)
            .start();

    }


    function draw(words) {
        const margin = {top: 60, right: 60, bottom: 60, left: 60}; // 增加边距
        const width = chartWidth - margin.left - margin.right;  // 减去左右间距
        const height = chartHeight - margin.top - margin.bottom; // 减去上下间距

        let svg = d3.select('#word_cloud')
            .attr("viewBox", [0, 0, chartWidth, chartHeight])
            .attr("style", "width: 100%; height: 100%;");

        let g = svg.append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Append words to the g element
        let text = g.selectAll("text")
            .data(words)
            .enter().append("text")
            .style("font-size", function (d) {
                return d.size + "px";
            })
            .style("fill", function (d) {
                var color = randomColor();
                colorMap[d.text] = color; // Store the color for each word
                return color; // Initial color without transparency
            })
            .attr("text-anchor", "middle")
            .style('cursor', 'pointer')
            .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
            })
            .text(function (d) {
                return d.text;
            })
            .on('click', function (e, d) {
                FindPaperHasKeyword(d.text);
            });

        // Calculate the bounding box of the g element
        let bbox = g.node().getBBox();
        let xOffset = (width - bbox.width) / 2 - bbox.x;
        let yOffset = (height - bbox.height) / 2 - bbox.y;

        // Apply translation to center the g element within the svg
        g.attr("transform", "translate(" + (margin.left + xOffset) + "," + (margin.top + yOffset) + ")");
    }

    function randomColor() {
        let colors = ['#73846a', '#c78c50', '#4f6157', '#7298c5',
            '#9e938a', '#68aab6', '#7c4e4c', '#333333',
            '#827473', '#8e9898', '#deb9ae', '#b8bec1']; // 这是你的颜色列表
        let randomIndex = Math.floor(Math.random() * colors.length);
        return colors[randomIndex];
    }


</script>

<script>
    $(document).ready(function () {
        // 分别调用每个图表的绘制函数
        {#d3.select("#chart1").call(createChart1);#}
        {#d3.select("#chart2").call(createChart2);#}
        {#d3.select("#chart3").call(createChart3);#}
        {#d3.select("#chart4").call(createChart4);#}
        loadDataForChart()
        LoadKeywords()
    });

    function loadDataForChart() {
        $.ajax({
            url: 'http://127.0.0.1:8000/data_neo4j/forChart',
            type: 'get',
            data: {},
            success: function (res) {
                let request = JSON.parse(res)
                console.log(request)
                createChart(d3.select('#chart_d_y'), request['chart_d_y'])
                createDonut(d3.select('#donut'), request['donut'])
                drawTreemap(d3.select('#treemap'), request['heatmap'])
            }
        });
    }
</script>

</body>
</html>
