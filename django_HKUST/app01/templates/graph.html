{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>KG</title>
    <link rel="stylesheet" href="{% static 'css/for_graph.css' %}">
</head>
<body>

<div id="container_kg" class="kg_container" style="height: 100%;width: 100%">
    {#    <div class="legend-container">#}
    {#        <div class="legend-title">Legend ▼</div>#}
    {#        <div class="legend-content">#}
    {#            <div class="legend-divider"></div>#}
    {#            <div class="legend-item">#}
    {#                <div class="legend-label">Dept.</div>#}
    {#                <div class="legend-gradient department"></div>#}
    {#            </div>#}
    {#            <div class="legend-item">#}
    {#                <div class="legend-label">Author’s works</div>#}
    {#                <div class="legend-gradient authorForLegend"></div>#}
    {#                <div class="legend-scale">#}
    {#                    <span>Less</span>#}
    {#                    <span>More</span>#}
    {#                </div>#}
    {#            </div>#}
    {#            <div class="legend-item">#}
    {#                <div class="legend-label">Paper citations</div>#}
    {#                <div class="legend-gradient paperForLegend"></div>#}
    {#                <div class="legend-scale">#}
    {#                    <span>Less</span>#}
    {#                    <span>More</span>#}
    {#                </div>#}
    {#            </div>#}
    {#        </div>#}
    {#    </div>#}
</div>

<script src="{% static 'js/jquery-3.7.1.js' %}"></script>
<script src="{% static 'plugins/d3/d3.v7.js' %}"></script>


<script>

    // Specify the dimensions of the chart.
    const width = d3.select('.kg_container').node().getBoundingClientRect().width
    const height = d3.select('.kg_container').node().getBoundingClientRect().height

    // Specify the color scale.
    let color = ['#f2a7da', '#71b7ed', '#f8dc4c', 'grey', '#84c3b7', 'black']
    let color_key = '#f8dc4c'
    // 定义颜色比例尺，根据citation的范围调整颜色的深浅
    const colorScale = d3.scaleLinear()
        .domain([2020, 2024])
        .range(["#e6b1be", "#d14163"]);

    const colorScale_auther = d3.scaleLinear()
        .domain([18, 249])
        .range(["#b9ded3", "#007f5f"]);

    // Create the SVG container.     preserveAspectRatio="xMinYMin meet"
    const svg = d3.select('#container_kg').append("svg")
        .attr('id', 'graph_svg')
        .style("width", '100%')
        .style("height", 'auto')
        .attr("viewBox", [0, 0, width, height])
        .on('click', function (e) {
            if (e.target.tagName === 'svg') {
                resetNodeColors();
            }
        })


    function createMarker(id, d, fill, opacity, refX, refY) {
        refX = 0
        refY = 0
        return svg.append('marker')
            .attr('id', id)
            .attr('orient', 'auto')
            .attr('stroke-width', 2)
            .attr('markerUnits', 'strokeWidth')
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', refX)
            .attr('refY', refY)
            .attr('markerWidth', 12)
            .attr('markerHeight', 12)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', d)
            .attr('fill', fill)
            .attr('stroke-opacity', opacity);
    }

    const positiveMarker = createMarker('positiveMarker', 'M 0 -5 L 10 0 L 0 5', color[3], 0.1, 25, 0);
    const negativeMarker = createMarker('negativeMarker', 'M 10 -5 L 0 0 L 10 5', color[3], 0.1, -15, 0);


    {#svg.append('rect').attr('id', 'rect').attr('height', '100%').attr('width', '100%').attr('fill', 'white')#}

    const g = svg.append('g').attr('id', 'graph_svg_g')

    const zoom = d3.zoom().scaleExtent([0.1, 10]).on('zoom', function (event) {
        g.attr('transform', event.transform)
    })
    svg.call(zoom)


    let link
    let link_name
    let node
    let entity_data
    let simulation
    let nodeNameText
    let nodes, links;

    // Reheat the simulation when drag starts, and fix the subject position.
    function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
    }

    function dragged(event) {
        const draggedNode = event.subject;

        // 更新作者节点的位置
        draggedNode.fx = event.x;
        draggedNode.fy = event.y;


        // 更新与作者节点连接的 paper 节点的位置
        if (draggedNode.group === 4) {
            // 过滤出与拖动节点相关的 paper 节点
            const relatedPapers = nodes.filter(node =>
                links.some(link =>
                    link.source.name === draggedNode.name && link.target.name === node.name
                )
            );
            relatedPapers.forEach(paper => {
                // 计算拖动的方向
                const dx = event.x - draggedNode.x;
                const dy = event.y - draggedNode.y;

                // 添加阻尼系数，使得 paper 节点具有滞后效果
                const damping = 1; // 可以根据需要调整这个值

                // 将 paper 节点设置为跟随拖动方向，但有滞后效果
                paper.fx = paper.x + dx * damping;
                paper.fy = paper.y + dy * damping;
            });
        }

        simulation.alphaTarget(0.1).restart();  // 重新启动模拟
    }

    function dragended(event) {
        const draggedNode = event.subject;

        // 还原拖动后的节点位置
        draggedNode.fx = null;
        draggedNode.fy = null;

        draggedNode.fx = event.x;
        draggedNode.fy = event.y;

        // 还原与作者节点连接的 paper 节点的位置
        if (draggedNode.group === 4) {
            const relatedPapers = nodes.filter(node =>
                links.some(link =>
                    link.source.name === draggedNode.name && link.target.name === node.name)
            );

            relatedPapers.forEach(paper => {
                // 移除纸节点的力中心
                simulation.force("center" + paper.name, null);
                paper.fx = null;
                paper.fy = null;
            });
        }

        simulation.alphaTarget(0.03);  // 停止模拟加速
    }

    // 创建tooltip


</script>

<script>
    $(document).ready(function () {
        LoadData2()
    });

    function filterNode(data) {
        let filter_node = data.nodes.filter(node => node.citation > min_citation || node.group === 4 || node.group === 1);
        let filter_node_names = new Set(filter_node.map(node => node.name));

        // 筛选链接
        let filter_link = data.links.filter(link =>
            filter_node_names.has(link.source) && filter_node_names.has(link.target)
        );
        updateGraph({'nodes': filter_node, 'links': filter_link})
    }

    function removeNode(data) {
        let filter_node = data.nodes.filter(node => node.citation > min_citation || node.group === 4 || node.group === 1);
        let filter_node_names = new Set(filter_node.map(node => node.name));

        // 筛选链接
        let filter_link = data.links.filter(link =>
            filter_node_names.has(link.source) && filter_node_names.has(link.target)
        );
        InitGraph({'nodes': filter_node, 'links': filter_link})
    }

    function LoadData2() {
        $.ajax({
            url: 'http://127.0.0.1:8000/graph/query_all/',
            type: 'get',
            data: {'name': ''},
            success: function (res) {
                entity_data = JSON.parse(res)
                removeNode(entity_data)
            }
        })
    }

    function LoadData() {
        $.ajax({
            url: 'http://127.0.0.1:8000/graph/query/',
            type: 'get',
            data: {'name': ''},
            success: function (res) {
                let request = JSON.parse(res)
                entity_data = {
                    'nodes': request,
                    'links': []
                }
                InitGraph(entity_data)
            }
        })
    }

    function query_paper(name) {
        $.ajax({
            url: 'http://127.0.0.1:8000/graph/query_paper/',
            type: 'get',
            data: {'name': name},
            success: function (res) {
                let request = JSON.parse(res)['results']
                let count = JSON.parse(res)['count']

                for (let i = 0; i < request.length; i++) {
                    let flag = true
                    for (let j = 0; j < entity_data.nodes.length; j++) {
                        if (entity_data.nodes[j].name === request[i].name) {
                            flag = false
                            break
                        }
                    }
                    if (flag) {
                        entity_data.nodes.push(request[i])
                    }

                    entity_data.links.push({
                        'source': name,
                        'target': request[i].name,
                        'value': 3,
                        'relationship': 'OWNED BY'
                    })
                }
                entity_data.links = Array.from(new Set(entity_data.links.map(JSON.stringify))).map(JSON.parse);
                filterNode(entity_data)
                {#updateGraph(entity_data)#}
            }
        })
    }

    let already_click_author = []

    function updateGraph(data) {

        nodes = data.nodes.map(d => ({...d}))
        links = data.links.map(d => ({...d}))

        // 通过 ID 找到现有节点
        const existingNodes = new Map(node.data().map(d => [d.name, d]));

        // 将已有节点的位置保持不变
        nodes.forEach(node => {
            if (existingNodes.has(node.name)) {
                // 保持现有节点的位置不变
                node.x = existingNodes.get(node.name).x;
                node.y = existingNodes.get(node.name).y;
            }
        });


        const authorNodes = nodes.filter(node => node.group === 4);
        const paperNodes = nodes.filter(node => node.group === 0);

        authorNodes.forEach((author) => {

            const papers = paperNodes.filter(paper => links.some(link => link.source === author.name && link.target === paper.name));
            let radius = 50;
            let currentCircleNodeCount = 0;
            let angleStep;

            // 计算每个paper节点的位置
            papers.forEach(paper => {
                // 找到与当前paper节点连接的所有author节点
                const connectedAuthors = nodes.filter(node =>
                    links.some(link => (link.source === node.name && link.target === paper.name) ||
                        (link.target === node.name && link.source === paper.name))
                );

                if (connectedAuthors.length > 1) {
                    // 计算所有连接的author节点的中心位置
                    const sum = connectedAuthors.reduce((acc, author) => {
                        acc.x += author.x;
                        acc.y += author.y;
                        return acc;
                    }, {x: 0, y: 0});

                    paper.x = sum.x / connectedAuthors.length;
                    paper.y = sum.y / connectedAuthors.length;
                } else {
                    // 如果没有连接的author节点，按原来的方式计算
                    if (currentCircleNodeCount === 0 || currentCircleNodeCount === Math.floor(2 * Math.PI * radius / 50)) {
                        radius += 50;
                        currentCircleNodeCount = 0;
                        angleStep = 2 * Math.PI / Math.floor(2 * Math.PI * radius / 50);
                    }
                    const currentAngle = currentCircleNodeCount * angleStep + 5;
                    paper.x = author.x + radius * Math.cos(currentAngle);
                    paper.y = author.y + radius * Math.sin(currentAngle);
                    currentCircleNodeCount++;
                }
            });

        });

        // 找到有多个作者连接的 paper 节点
        const paperLinkCount = {};
        links.forEach(link => {
            if (link.target in paperLinkCount) {
                paperLinkCount[link.target]++;
            } else {
                paperLinkCount[link.target] = 1;
            }
        });

        links.forEach(link => {
            const sourceNode = nodes.find(node => node.name === link.source);
            const targetNode = nodes.find(node => node.name === link.target);
            if (sourceNode && targetNode) {
                if (targetNode.group === 0) { // 如果目标节点是论文节点
                    // 使用引用次数作为半径，设定最大半径为150
                    let paperRadius = Math.min(targetNode.citation, 150);
                    // 将引用次数线性映射到距离范围内
                    let maxDistance = 500;  // 最大距离
                    let minDistance = 150;  // 最小距离
                    link.distance = Math.max(minDistance, maxDistance - paperRadius * (maxDistance - minDistance) / 100);
                } else {
                    // 对于非论文节点，保持原来的距离计算方式
                    const dx = sourceNode.x - targetNode.x;
                    const dy = sourceNode.y - targetNode.y;
                    link.distance = Math.sqrt(dx * dx + dy * dy);
                }
            }
        });


        link = link.data(links, d => `${d.source.name}_${d.target.name}`)
        link.exit().remove();
        link = link
            .enter()
            .append("path")
            .attr("stroke", color[3])
            .attr("stroke-opacity", (d) => {
                if (d.relationship === 'BELONGS_TO') {
                    return 1
                } else {
                    return 0.6
                }
            })
            .attr('marker-end', 'url(#direction)')
            .attr('id', d => d.source + '_' + d.relationship + '_' + d.target)
            .attr("stroke-width", (d) => {
                if (d.relationship === 'BELONGS_TO') {
                    return 5
                } else {
                    return 3
                }
            })
            .merge(link);


        node = node.data(nodes, d => d.name);
        node.exit().remove();
        node = node.enter().append("circle")
            .attr("r", (d) => {
                if (d.group === 1) {
                    return 100
                }
                if (d.group === 4) {
                    return 70
                }
                if (d.group === 0) {
                    if (d.citation < 21) {
                        return 10
                    } else if (d.citation > 20 && d.citation < 51) {
                        return 20
                    } else if (d.citation > 50 && d.citation < 101) {
                        return 30
                    } else if (d.citation > 100 && d.citation < 151) {
                        return 40
                    } else {
                        return 50
                    }
                }
            })
            .attr("fill", (d) => {
                if (d.group === 0) {
                    return colorScale(parseInt(d.released));
                } else if (d.group === 4) {
                    return colorScale_auther(d.count)
                } else {
                    if (d.name === "AI") {
                        return '#98abc5'
                    } else if (d.name === "CMA") {
                        return '#8a89a6'
                    } else if (d.name === 'DSA') {
                        return '#7b6888'
                    }
                }
            })
            .attr('class', 'circle')
            .merge(node)
            .on('click', function (e, d) {
                // Set the clicked node as the selected node
                selectedNode = d;
                if (d.group === 1) {
                    // Call the function to highlight the neighborhood
                    highlightNeighborhood_2(selectedNode);
                } else {
                    highlightNeighborhood(selectedNode)
                }
            });

        node.on('mouseover', function (event, d) {
            tooltip.transition().duration(200).style("opacity", .9);
            tooltip.html(
                () => {
                    if (d.group === 4) {
                        return '<div class="publication-card" style="text-align: left">' +
                            '<h4>' + d.name + '</h4>' +
                            '<p>' + d.count + ' papers</p>' +
                            '<br>' +
                            '</div>'
                    } else if (d.group === 1) {
                        return d.name
                    } else {
                        let temp_path = '/static/img/' + d.id + '.png'
                        return '<div class="publication-card" style="width: 600px; text-align: left">' +
                            '<div class="entry_img">' +
                            '<img class="thumb" src="' + temp_path + '" alt="">' +
                            '</div>' +
                            '<div class="entry_main">' +
                            '<h4>' + d.name + '</h4>' +
                            '<p>' + d.authors + '</p>' +
                            '<br>' +
                            '<p>Published:' + d.released + '</p>' +
                            '<p>Venue:' + d.venue + '</p>' +
                            '</div>' +
                            '</div>'
                    }
                })
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px")
            ;
        })
            .on('mouseout', function (d) {
                tooltip.transition().duration(500).style("opacity", 0);
            });


        nodeNameText = nodeNameText.data(nodes, d => d.name)
        nodeNameText.exit().remove()
        nodeNameText.enter().append('text')
            .merge(nodeNameText)

        simulation.nodes(nodes);
        simulation.force('link').links(links);

        simulation.alpha(0.2).restart();


        // Add a drag behavior.
        node.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        setTimeout(fitViewBox, 1000)
    }

    function InitGraph(data) {
        // 图例折叠功能
        d3.select(".legend-title").on("click", function () {
            const content = d3.select(".legend-content");
            if (content.style("display") === "none") {
                content.style("display", "block");
                d3.select(this).text("Legend ▲");
            } else {
                content.style("display", "none");
                d3.select(this).text("Legend ▼");
            }
        });

        // so that re-evaluating this cell produces the same result.
        links = data.links.map(d => ({...d}));
        nodes = data.nodes.map(d => ({...d}));

        const departmentNodes = nodes.filter(node => node.group === 1)
        const authorNodes = nodes.filter(node => node.group === 4);
        const paperNodes = nodes.filter(node => node.group === 0);

        // 给每个节点一个初始位置，避免重叠
        departmentNodes.forEach((node, index) => {
            node.x = width / 2 + 1200 * Math.cos(index * 2 * Math.PI / departmentNodes.length);
            node.y = height / 2 + 1200 * Math.sin(index * 2 * Math.PI / departmentNodes.length);
        });

        {#const spacing = 2000; // 你想要的节点之间的固定间距#}
        {##}
        {#departmentNodes.forEach((node, index) => {#}
        {#    node.x = (width - spacing * (departmentNodes.length - 1)) / 2 + spacing * index;#}
        {#    node.y = height / 2; // 保持所有节点在垂直方向上的位置一致#}
        //});

        departmentNodes.forEach((department) => {
            const authors = authorNodes.filter(
                author => links.some(link => link.source === department.name && link.target === author.name));
            authors.forEach((node, index) => {
                node.x = department.x + 800 * Math.cos(index * 2 * Math.PI / authors.length);
                node.y = department.y + 800 * Math.sin(index * 2 * Math.PI / authors.length);
            });

        });

        authorNodes.forEach((author) => {

            const papers = paperNodes.filter(paper => links.some(link => link.source === author.name && link.target === paper.name));
            let radius = 50;
            let currentCircleNodeCount = 0;
            let angleStep;

            // 计算每个paper节点的位置
            papers.forEach(paper => {
                // 找到与当前paper节点连接的所有author节点
                const connectedAuthors = nodes.filter(node =>
                    links.some(link => (link.source === node.name && link.target === paper.name) ||
                        (link.target === node.name && link.source === paper.name))
                );

                if (connectedAuthors.length > 1) {
                    // 计算所有连接的author节点的中心位置
                    const sum = connectedAuthors.reduce((acc, author) => {
                        acc.x += author.x;
                        acc.y += author.y;
                        return acc;
                    }, {x: 0, y: 0});

                    paper.x = sum.x / connectedAuthors.length;
                    paper.y = sum.y / connectedAuthors.length;
                } else {
                    // 如果没有连接的author节点，按原来的方式计算
                    if (currentCircleNodeCount === 0 || currentCircleNodeCount === Math.floor(2 * Math.PI * radius / 50)) {
                        radius += 50;
                        currentCircleNodeCount = 0;
                        angleStep = 2 * Math.PI / Math.floor(2 * Math.PI * radius / 50);
                    }
                    const currentAngle = currentCircleNodeCount * angleStep + 5;
                    paper.x = author.x + radius * Math.cos(currentAngle);
                    paper.y = author.y + radius * Math.sin(currentAngle);
                    currentCircleNodeCount++;
                }
            });

        });

        // 找到有多个作者连接的 paper 节点
        const paperLinkCount = {};
        links.forEach(link => {
            if (link.target in paperLinkCount) {
                paperLinkCount[link.target]++;
            } else {
                paperLinkCount[link.target] = 1;
            }
        });

        links.forEach(link => {
            const sourceNode = nodes.find(node => node.name === link.source);
            const targetNode = nodes.find(node => node.name === link.target);
            if (sourceNode && targetNode) {
                if (targetNode.group === 0) { // 如果目标节点是论文节点
                    // 使用引用次数作为半径，设定最大半径为150
                    let paperRadius = Math.min(targetNode.citation, 150);
                    // 将引用次数线性映射到距离范围内
                    let maxDistance = 500;  // 最大距离
                    let minDistance = 150;  // 最小距离
                    link.distance = Math.max(minDistance, maxDistance - paperRadius * (maxDistance - minDistance) / 100);
                } else {
                    // 对于非论文节点，保持原来的距离计算方式
                    const dx = sourceNode.x - targetNode.x;
                    const dy = sourceNode.y - targetNode.y;
                    link.distance = Math.sqrt(dx * dx + dy * dy);
                }
            }
        });


        simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.name).distance(function (d) {
                return d.distance
            }))

            .force('collision', d3.forceCollide().radius(50))
            .force("charge", d3.forceManyBody().strength(-50))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .alphaMin(0.05)
            .on("tick", ticked);


        // Add a line for each link, and a circle for each node.
        link = g.append("g")
            .attr("stroke", color[3])
            .selectAll()
            .data(links)
            .join("path")
            .attr("stroke-opacity", (d) => {
                if (d.relationship === 'BELONGS_TO') {
                    return 1
                } else {
                    return 0.6
                }
            })
            .attr('stroke-width', (d) => {
                if (d.relationship === 'BELONGS_TO') {
                    return 5
                } else {
                    return 3
                }

            })
            .attr('id', d => d.source + '_' + d.relationship + '_' + d.target);

        node = g.append("g")
            .attr("stroke", '#ffffff')
            .attr("stroke", color[5])
            .attr("stroke-width", 1.5)
            .selectAll()
            .data(nodes)
            .join("circle")
            .attr("r", (d) => {
                if (d.group === 1) {
                    return 100
                }
                if (d.group === 4) {
                    return 70
                }
                if (d.group === 0) {
                    if (d.citation < 21) {
                        return 10
                    } else if (d.citation > 20 && d.citation < 51) {
                        return 20
                    } else if (d.citation > 50 && d.citation < 101) {
                        return 30
                    } else if (d.citation > 100 && d.citation < 151) {
                        return 40
                    } else {
                        return 50
                    }
                }
            })
            .attr("fill", (d) => {
                if (d.group === 0) {
                    return colorScale(parseInt(d.released));
                } else if (d.group === 4) {
                    return colorScale_auther(d.count)
                } else {
                    if (d.name === "AI") {
                        return '#247181'
                    } else if (d.name === "CMA") {
                        return '#619ea9'
                    } else if (d.name === 'DSA') {
                        return '#224659'
                    }
                }
            })
            .attr('class', 'circle')
            .on('click', function (e, d) {
                // Set the clicked node as the selected node
                selectedNode = d;
                console.log(d)
                if (d.group === 1) {
                    // Call the function to highlight the neighborhood
                    highlightNeighborhood_2(selectedNode);
                } else {
                    highlightNeighborhood(selectedNode)
                }

            })

        node.on('mouseover', function (event, d) {
            tooltip.transition().duration(200).style("opacity", .9);
            tooltip.html(
                () => {
                    if (d.group === 4) {
                        return '<div class="publication-card" style="text-align: left">' +
                            '<h4>' + d.name + '</h4>' +
                            '<p>' + d.count + ' papers</p>' +
                            '<br>' +
                            '</div>'
                    } else if (d.group === 1) {
                        return d.name
                    } else {
                        let temp_path = '/static/img/' + d.id + '.png'
                        return '<div class="publication-card" style="width: 600px; text-align: left">' +
                            '<div class="entry_img">' +
                            '<img class="thumb" src="' + temp_path + '" alt="">' +
                            '</div>' +
                            '<div class="entry_main">' +
                            '<h4>' + d.name + '</h4>' +
                            '<p>' + d.authors + '</p>' +
                            '<br>' +
                            '<p>Citation:' + d.citation + '</p>' +
                            '<p>Published:' + d.released + '</p>' +
                            '<p>Venue:' + d.venue + '</p>' +
                            '</div>' +
                            '</div>'
                    }
                })
                .style("left", (event.pageX + 50) + "px")
                .style("top", (event.pageY - 140) + "px")
            ;
        })
            .on('mouseout', function (d) {
                tooltip.transition().duration(500).style("opacity", 0);
            });

        nodeNameText = g.append('g').selectAll().data(nodes).join('text')
            .text((d) => {
                if (d.group === 4 || d.group === 1) {
                    return d.name
                }
            })
            .attr('dy', (d) => {
                if (d.group === 1) {
                    return 15
                } else {
                    return 10
                }
            })
            .attr('fill', color[5])
            .attr('font-size', (d) => {
                if (d.group === 1) {
                    return '40px';  // 对于 group 1 的字体大小
                } else {
                    return '20px';  // 对于其他组的字体大小
                }
            });

        // 然后通过 each 方法调整 dx 属性
        nodeNameText.each(function (d) {
            const bbox = this.getBBox();
            d3.select(this).attr('dx', -bbox.width / 2);
        });

        // Add a drag behavior.
        node.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        // Set the position attributes of links and nodes each time the simulation ticks.
        function ticked() {
            link
                .attr('d', function (d) {
                    if (d.source.x < d.target.x) {
                        return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y
                    } else {
                        return 'M ' + d.target.x + ' ' + d.target.y + ' L ' + d.source.x + ' ' + d.source.y
                    }
                })

            node.attr("cx", d => d.x).attr("cy", d => d.y);

            nodeNameText.attr("x", d => d.x).attr("y", d => d.y);
        }


        setTimeout(fitViewBox, 1000)


    }

    function InitGraphByQA(data) {
        // so that re-evaluating this cell produces the same result.
        links = data.links.map(d => ({...d}));
        nodes = data.nodes.map(d => ({...d}));



        const deptNodes = nodes.filter(node => node.group === 1);
        const authorNodes = nodes.filter(node => node.group === 4);
        const paperNodes = nodes.filter(node => node.group === 0);
        const keywordNodes = nodes.filter(node => node.group === 2);
        console.log(deptNodes)

        // 给每个节点一个初始位置，避免重叠
        authorNodes.forEach((node, index) => {
            node.x = width / 2 + 600 * Math.cos(index * 2 * Math.PI / authorNodes.length);
            node.y = height / 2 + 600 * Math.sin(index * 2 * Math.PI / authorNodes.length);
        });

        authorNodes.forEach((author) => {
            const papers = paperNodes.filter(
                paper => links.some(link => link.source === author.name && link.target === paper.name));
            papers.forEach((node, index) => {
                node.x = author.x + 400 * Math.cos(index * 2 * Math.PI / papers.length);
                node.y = author.y + 400 * Math.sin(index * 2 * Math.PI / papers.length);
            });
        });

        authorNodes.forEach((author) => {
            const depts = deptNodes.filter(
                dept => links.some(link => link.source === author.name && link.target === dept.name));
            depts.forEach((node, index) => {
                node.x = author.x + 400 * Math.cos(index * 2 * Math.PI / depts.length);
                node.y = author.y + 400 * Math.sin(index * 2 * Math.PI / depts.length);
            });
        });

        paperNodes.forEach((paper) => {
            const keywords = keywordNodes.filter(
                keyword => links.some(link => link.source === paper.name && link.target === keyword.name));
            keywords.forEach((node, index) => {
                node.x = paper.x + 200 * Math.cos(index * 2 * Math.PI / keywords.length);
                node.y = paper.y + 200 * Math.sin(index * 2 * Math.PI / keywords.length);
            });
        });

        links.forEach(link => {
            const sourceNode = nodes.find(node => node.name === link.source);
            const targetNode = nodes.find(node => node.name === link.target);
            if (sourceNode && targetNode) {
                // 对于非论文节点，保持原来的距离计算方式
                const dx = sourceNode.x - targetNode.x;
                const dy = sourceNode.y - targetNode.y;
                link.distance = Math.sqrt(dx * dx + dy * dy);
            }
        });


        simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.name).distance(function (d) {
                return d.distance
            }))

            .force('collision', d3.forceCollide().radius(35))
            .force("charge", d3.forceManyBody().strength(-50))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .alphaMin(0.05)
            .on("tick", ticked);

        // Add a line for each link, and a circle for each node.
        link = g.append("g")
            .attr("stroke", color[3])
            .selectAll()
            .data(links)
            .join("path")
            .attr("stroke-opacity", (d) => {
                if (d.relationship === 'OWNED_BY') {
                    return 1
                } else {
                    return 0.6
                }
            })
            .attr('stroke-width', (d) => {
                if (d.relationship === 'OWNED_BY') {
                    return 5
                } else {
                    return 3
                }

            })
            .attr('id', d => d.source + '_' + d.relationship + '_' + d.target);

        node = g.append("g")
            .attr("stroke", color[5])
            .attr("stroke-width", 1.5)
            .selectAll()
            .data(nodes)
            .join("circle")
            .attr("r", (d) => {
                return 30
            })
            .attr("fill", (d) => {
                if (d.group === 0) {
                    return colorScale(parseInt(d.released));
                } else if (d.group === 4) {
                    return colorScale_auther(d.count)
                } else if (d.group === 2){
                    return '#ffdf60'
                }else {
                    if (d.name === "AI") {
                        return '#247181'
                    } else if (d.name === "CMA") {
                        return '#619ea9'
                    } else if (d.name === 'DSA') {
                        return '#224659'
                    }
                }
            })
            .attr('class', 'circle')
            .on('click', function (e, d) {
                if (d.group === 0) {
                    query_list.push(d.id)
                    query_id_list.push(d.id)
                    QueryResults()
                    fixSelectors(d.id)
                }
                if (d.group === 4) {
                    if (already_click_author.indexOf(d.name) === -1 || already_click_author.length === 0) {
                        query_paper(d.name);
                    }
                    already_click_author.push(d.name)
                    query_list.push(d.name)
                    query_author_list.push(d.name)
                    QueryResults()
                    fixSelectors(d.name)
                }
            })

        node.on('mouseover', function (event, d) {
            tooltip.transition().duration(200).style("opacity", .9);
            {#tooltip.html(function(d) {return d.name})#}
            tooltip.html(
                () => {
                    if (d.group === 4) {
                        return '<div class="publication-card" style="text-align: left">' +
                            '<h4>' + d.name + '</h4>' +
                            '<p>' + d.count + ' papers</p>' +
                            '<br>' +
                            '</div>'
                    } else if (d.group === 1 || d.group === 2) {
                        return d.name
                    } else {
                        let temp_path = '/static/img/' + d.id + '.png'
                        return '<div class="publication-card" style="width: 600px; text-align: left">' +
                            '<div class="entry_img">' +
                            '<img class="thumb" src="' + temp_path + '" alt="">' +
                            '</div>' +
                            '<div class="entry_main">' +
                            '<h4>' + d.name + '</h4>' +
                            '<p>' + d.authors + '</p>' +
                            '<br>' +
                            '<p>Citation:' + d.citation + '</p>' +
                            '<p>Published:' + d.released + '</p>' +
                            '<p>Venue:' + d.venue + '</p>' +
                            '</div>' +
                            '</div>'
                    }
                })
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
            .on('mouseout', function (d) {
                tooltip.transition().duration(500).style("opacity", 0);
            });

        nodeNameText = g.append('g').selectAll().data(nodes).join('text')
            .text((d) => {
                if (d.group === 4 || d.group === 1 || d.group === 2) {
                    return d.name
                }
            })
            .attr('dy', (d) => {
                if (d.group === 1) {
                    return 8
                } else {
                    return 45
                }
            })
            .attr('fill', color[5])

        // 然后通过 each 方法调整 dx 属性
        nodeNameText.each(function (d) {
            const bbox = this.getBBox();
            d3.select(this).attr('dx', -bbox.width / 2);
        });

        // Add a drag behavior.
        node.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));


        // Set the position attributes of links and nodes each time the simulation ticks.
        function ticked() {
            link
                .attr('d', function (d) {
                    if (d.source.x < d.target.x) {
                        return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y
                    } else {
                        return 'M ' + d.target.x + ' ' + d.target.y + ' L ' + d.source.x + ' ' + d.source.y
                    }
                })

            node.attr("cx", d => d.x).attr("cy", d => d.y);

            nodeNameText.attr("x", d => d.x).attr("y", d => d.y);
        }


        setTimeout(fitViewBox, 1000)

    }

    function removeGraphNode() {
        enableComponent()
        let clear = {
            'nodes': [],
            'links': [],
        }
        
        updateGraph(clear)
        removeNode(entity_data)
    }

    function fitViewBox() {
        // 获取当前的变换
        const transform = d3.zoomTransform(svg.node());
        // 计算节点的边界框
        const xExtent = d3.extent(nodes, d => d.x);
        const yExtent = d3.extent(nodes, d => d.y);
        // 计算节点的中心点
        const xCenter = (xExtent[0] + xExtent[1]) / 2;
        const yCenter = (yExtent[0] + yExtent[1]) / 2;

        // 计算边界框的宽度和高度
        const widthExtent = xExtent[1] - xExtent[0];
        const heightExtent = yExtent[1] - yExtent[0];


        // 计算缩放比例，使节点完全显示在视图中
        const scale = Math.min(
            (width - 50) / widthExtent,
            (height - 50) / heightExtent
        );


        // 计算平移量以使节点居中
        const tx = xCenter - width / scale / 2
        const ty = yCenter - height / scale / 2


        // 应用缩放和平移变换
        svg.transition()
            .call(zoom.transform, d3.zoomIdentity)
            .on('end', () => {
                svg.transition().duration(750)
                    .attr("viewBox", `${tx} ${ty} ${width / scale} ${height / scale}`)
                    .on('end', () => {
                        svg.attr("viewBox", `${tx} ${ty} ${width / scale} ${height / scale}`);
                    });
            });
    }


    let selectedNode = null;

    // Function to highlight the selected node and its first-order neighbors
    function highlightNeighborhood(selectedNode) {
        const neighbors = new Set();

        // Find the neighbors (first-order connections)
        links.forEach(link => {
            if (link.source.name === selectedNode.name) {
                neighbors.add(link.target.name);
            } else if (link.target.name === selectedNode.name) {
                neighbors.add(link.source.name);
            }
        });
        neighbors.add(selectedNode.name); // Also include the selected node itself

        // Update the color of nodes
        node.attr('fill', (n) => {
            if (neighbors.has(n.name)) {
                // Original color for the selected node and its neighbors
                if (n.group === 0) {
                    return colorScale(parseInt(n.released));
                } else if (n.group === 4) {
                    return colorScale_auther(n.count);
                } else {
                    if (n.name === "AI") {
                        return '#247181';
                    } else if (n.name === "CMA") {
                        return '#619ea9';
                    } else if (n.name === 'DSA') {
                        return '#224659';
                    }
                }
            } else {
                // Lighten color for other nodes
                return "#ddd"; // or use a different light color
            }
        });

        // Update the color of links
        link.attr("stroke", (l) => {
            if (neighbors.has(l.source.name) && neighbors.has(l.target.name)) {
                return color[3]; // Original color for links between selected node and its neighbors
            } else {
                return "#ddd"; // Lighten color for other links
            }
        }).attr("stroke-opacity", (l) => {
            if (neighbors.has(l.source.name) && neighbors.has(l.target.name)) {
                if (l.relationship === 'BELONGS_TO') {
                    return 1;
                } else {
                    return 0.6;
                }
            } else {
                return 0.3; // Reduce opacity for other links
            }
        });
    }

    function highlightNeighborhood_2(selectedNode) {
        const neighbors = new Set();
        const secondNeighbors = new Set();

        // Find the first-order neighbors (direct connections)
        links.forEach(link => {
            if (link.source.name === selectedNode.name) {
                neighbors.add(link.target.name);
            } else if (link.target.name === selectedNode.name) {
                neighbors.add(link.source.name);
            }
        });

        // Find the second-order neighbors (neighbors of first-order neighbors)
        links.forEach(link => {
            if (neighbors.has(link.source.name)) {
                secondNeighbors.add(link.target.name);
            } else if (neighbors.has(link.target.name)) {
                secondNeighbors.add(link.source.name);
            }
        });

        neighbors.add(selectedNode.name); // Include the selected node itself
        secondNeighbors.delete(selectedNode.name); // Avoid re-adding the selected node

        // Update the color of nodes
        node.attr('fill', (n) => {
            if (neighbors.has(n.name)) {
                // Original color for the selected node and its first-order neighbors
                if (n.group === 0) {
                    return colorScale(parseInt(n.released));
                } else if (n.group === 4) {
                    return colorScale_auther(n.count);
                } else {
                    if (n.name === "AI") {
                        return '#247181';
                    } else if (n.name === "CMA") {
                        return '#619ea9';
                    } else if (n.name === 'DSA') {
                        return '#234559';
                    }
                }
            } else if (secondNeighbors.has(n.name)) {
                // Original color for the selected node and its first-order neighbors
                if (n.group === 0) {
                    return colorScale(parseInt(n.released));
                } else if (n.group === 4) {
                    return colorScale_auther(n.count);
                } else {
                    if (n.name === "AI") {
                        return '#e3716e';
                    } else if (n.name === "CMA") {
                        return '#7ac7e2';
                    } else if (n.name === 'DSA') {
                        return '#f7df87';
                    }
                }
            } else {
                // Lighten color for other nodes
                return "#ddd"; // or use a different light color
            }
        });

        // Update the color of links
        link.attr("stroke", (l) => {
            if (neighbors.has(l.source.name) && neighbors.has(l.target.name)) {
                return color[3]; // Original color for links between selected node and its first-order neighbors
            } else if (secondNeighbors.has(l.source.name) || secondNeighbors.has(l.target.name)) {
                return "#aaa"; // Slightly different color for links to second-order neighbors
            } else {
                return "#ddd"; // Lighten color for other links
            }
        }).attr("stroke-opacity", (l) => {
            if (neighbors.has(l.source.name) && neighbors.has(l.target.name)) {
                if (l.relationship === 'BELONGS_TO') {
                    return 1;
                } else {
                    return 0.6;
                }
            } else if (secondNeighbors.has(l.source.name) || secondNeighbors.has(l.target.name)) {
                return 0.5; // Reduce opacity for second-order links
            } else {
                return 0.3; // Reduce opacity for other links
            }
        });
    }

    // Function to reset all nodes to their original colors
    function resetNodeColors() {
        node.attr('fill', (n) => {
            if (n.group === 0) {
                return colorScale(parseInt(n.released));
            } else if (n.group === 4) {
                return colorScale_auther(n.count);
            } else {
                if (n.name === "AI") {
                    return '#247181';
                } else if (n.name === "CMA") {
                    return '#619ea9';
                } else if (n.name === 'DSA') {
                    return '#224659';
                }
            }
        });

        link.attr("stroke", color[3])
            .attr("stroke-opacity", (d) => {
                if (d.relationship === 'BELONGS_TO') {
                    return 1;
                } else {
                    return 0.6;
                }
            });


        selectedNode = null; // Clear the selection
    }

    // Function to highlight papers published in a specific year and their neighbors
    function highlightPapersByYear(year) {
        const papers = nodes.filter(n => n.group === 0 && n.released === year);
        const neighbors = new Set();
        const relatedLinks = new Set();

        papers.forEach(paper => {
            neighbors.add(paper.name);
            links.forEach(link => {
                if (link.source.name === paper.name || link.target.name === paper.name) {
                    neighbors.add(link.source.name);
                    neighbors.add(link.target.name);
                    relatedLinks.add(link);
                }
            });
        });

        // Update the color of nodes
        node.attr('fill', (n) => {
            if (neighbors.has(n.name)) {
                // Original color for the paper and its neighbors
                if (n.group === 0) {
                    return colorScale(parseInt(n.released));
                } else if (n.group === 4) {
                    return colorScale_auther(n.count);
                } else {
                    if (n.name === "AI") {
                        return '#247181';
                    } else if (n.name === "CMA") {
                        return '#619ea9';
                    } else if (n.name === 'DSA') {
                        return '#224659';
                    }
                }
            } else {
                // Lighten color for other nodes
                return "#ddd"; // or use a different light color
            }
        });

        // Update the color of links
        link.attr("stroke", (l) => {
            if (relatedLinks.has(l)) {
                return color[3]; // Original color for links between papers and their neighbors
            } else {
                return "#ddd"; // Lighten color for other links
            }
        }).attr("stroke-opacity", (l) => {
            if (relatedLinks.has(l)) {
                if (l.relationship === 'BELONGS_TO') {
                    return 1;
                } else {
                    return 0.6;
                }
            } else {
                return 0.3; // Reduce opacity for other links
            }
        });
    }

    // Function to highlight nodes based on department and year
    function highlightByDepartmentAndYear(departmentName, year) {
        // Find the selected department
        const department = nodes.find(n => n.group === 1 && n.name === departmentName);
        if (!department) return;

        // Find authors belonging to this department
        const authors = nodes.filter(n => n.group === 4 &&
            links.some(l => l.source.name === department.name && l.target.name === n.name));

        const papers = [];
        const neighbors = new Set();
        const relatedLinks = new Set();

        authors.forEach(author => {
            // Add the author as a neighbor
            neighbors.add(author.name);

            // Find papers by this author in the selected year
            const authorPapers = nodes.filter(n => n.group === 0 && n.released === year &&
                links.some(l => l.source.name === author.name && l.target.name === n.name));
            papers.push(...authorPapers);

            // Add the paper as a neighbor
            authorPapers.forEach(paper => {
                neighbors.add(paper.name);

                // Add links related to this author and paper
                links.forEach(link => {
                    if ((link.source.name === author.name && link.target.name === paper.name) ||
                        (link.target.name === author.name && link.source.name === paper.name)) {
                        relatedLinks.add(link);
                    }
                });
            });
        });


        // Update the color of nodes
        node.attr('fill', (n) => {
            if (n.name === department.name || neighbors.has(n.name)) {
                // Original color for the department, authors, and papers
                if (n.group === 0) {
                    return colorScale(parseInt(n.released));
                } else if (n.group === 4) {
                    return colorScale_auther(n.count);
                } else {
                    if (n.name === "AI") {
                        return '#247181';
                    } else if (n.name === "CMA") {
                        return '#619ea9';
                    } else if (n.name === 'DSA') {
                        return '#224659';
                    }
                }
            } else {
                // Lighten color for other nodes
                return "#ddd"; // or use a different light color
            }
        });

        // Update the color of links
        link.attr("stroke", (l) => {
            if (relatedLinks.has(l) || (l.source.name === department.name && neighbors.has(l.target.name))) {
                return color[3]; // Original color for links between the department, authors, and papers
            } else {
                return "#ddd"; // Lighten color for other links
            }
        }).attr("stroke-opacity", (l) => {
            if (relatedLinks.has(l) || (l.source.name === department.name && neighbors.has(l.target.name))) {
                if (l.relationship === 'BELONGS_TO') {
                    return 1;
                } else {
                    return 0.6;
                }
            } else {
                return 0.3; // Reduce opacity for other links
            }
        });
    }

    function highlightNodesByNameList(nameList) {
        const nodesToHighlight = new Set(nameList);
        const neighbors = new Set();
        const relatedLinks = new Set();

        // Identify all nodes and links to be highlighted
        nodes.forEach(node => {
            if (nodesToHighlight.has(node.name)) {
                neighbors.add(node.name);
                links.forEach(link => {
                    if (link.source.name === node.name || link.target.name === node.name) {
                        neighbors.add(link.source.name);
                        neighbors.add(link.target.name);
                        relatedLinks.add(link);
                    }
                });
            }
        });

        // Update the color of nodes
        node.attr('fill', (n) => {
            if (neighbors.has(n.name)) {
                // Original color for the highlighted nodes and their neighbors
                if (n.group === 0) {
                    return colorScale(parseInt(n.released));
                } else if (n.group === 4) {
                    return colorScale_auther(n.count);
                } else {
                    if (n.name === "AI") {
                        return '#247181';
                    } else if (n.name === "CMA") {
                        return '#619ea9';
                    } else if (n.name === 'DSA') {
                        return '#234559';
                    }
                }
            } else {
                // Lighten color for other nodes
                return "#ddd"; // or use a different light color
            }
        });

        // Update the color and opacity of links
        link.attr("stroke", (l) => {
            if (relatedLinks.has(l)) {
                return color[3]; // Original color for links involving highlighted nodes
            } else {
                return "#ddd"; // Lighten color for other links
            }
        }).attr("stroke-opacity", (l) => {
            if (relatedLinks.has(l)) {
                if (l.relationship === 'BELONGS_TO') {
                    return 1;
                } else {
                    return 0.6;
                }
            } else {
                return 0.3; // Reduce opacity for other links
            }
        });
    }


</script>


</body>
</html>